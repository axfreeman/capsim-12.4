from fastapi import APIRouter, Depends
from app.authorization.authroutes import Authentication_handler
from app.database import get_db
from app.simulation.logging import report
from ..models import Commodity, Industry, SocialClass, Stock, User, Simulation
from sqlalchemy.orm import Session

# from sqlalchemy.orm.session import make_transient

router = APIRouter(prefix="/user", tags=["User"])


# VARIOUS SOLUTIONS TO CLONING
# CLONE FUNCTION USING DICTIONARY https://stackoverflow.com/questions/28871406/how-to-clone-a-sqlalchemy-object-with-new-primary-key
# INLINE CODE
# session.expunge(template)  # expunge the template from the session, releasing it so we can make a fresh coipy
# make_transient(template)  # http://docs.sqlalchemy.org/en/rel_1_1/orm/session_api.html#sqlalchemy.orm.session.make_transient
# session.add(template)
# FUNKY SOLUTION
# https://www.youtube.com/watch?v=7JlK9ac57SA
# https://lyz-code.github.io/blue-book/coding/python/sqlalchemy/
# NOTE THE ORIGINAL HAS TYPO ERROR - non_pk_columns in one place and non_primary_key_columns in another, '..keys' instead of 'keys'
# This briefer version of the above is suggested on https://stackoverflow.com/questions/28871406/how-to-clone-a-sqlalchemy-object-with-new-primary-key
# It has at least one distinct advantage, namely it works. I used it also because it is generic, so we don't have to repeat it for each model

def clone_model(model, session: Session, **kwargs):
    """Clone an arbitrary sqlalchemy model object without its primary key values."""
    table = model.__table__
    non_pk_columns = [
        k for k in table.columns.keys() if k not in table.primary_key.columns.keys()
    ]
    data = {c: getattr(model, c) for c in non_pk_columns}
    data.update(kwargs)
    clone = model.__class__(**data)
    session.add(clone)
    session.commit()
    return clone


@router.get("/clone/{id}")
def create_simulation_from_template(
    id: str,
    session: Session = Depends(get_db),
    username=Depends(Authentication_handler.auth_wrapper),
):
    this_user = (
        session.query(User).filter(User.username == username).first()
    )  # TODO the registration process should make it impossible to create two users with the same name but user could do something silly so TEST for this
    template = (
        session.query(Simulation).filter(Simulation.id == int(id)).first()
    )  # TODO TEST for this also
    report(
        1,
        1,
        f"Creating new simulation for user {username} from template {template.name}",
        session,
    )
    new_simulation = clone_model(template, session)
    print(f"new simulation pk is {new_simulation.id}")
    session.add(
        new_simulation
    )  # we commit twice, because we want to get the autogenerated id. There's probably a better way
    new_simulation.user_id = this_user.id
    new_simulation.state = "ACTIVE"
    session.commit()  # TODO reduce number of commits?

    # Clone all commodities in this simulation
    commodities = session.query(Commodity).filter(
        Commodity.simulation_id == template.id
    )
    for commodity in commodities:
        report(
            1,
            1,
            f"Cloning commodity {commodity.name}",
            session,
        )
        new_commodity = clone_model(commodity, session)
        session.add(
            new_commodity
        )  # we commit twice, because we want to get the autogenerated id. There's probably a better way
        session.add(commodity) # seems to be transient after it is committed, which is a bit weird. So bring it out again, because we will modify it by adding successor_id
        new_commodity.simulation_id = new_simulation.id
        commodity.successor_id=new_commodity.id
        session.commit()

    # Clone all industries in this simulation

    industries = session.query(Industry).filter(Industry.simulation_id == template.id)
    for industry in industries:
        report(
            1,
            1,
            f"Cloning industry {industry.name}",
            session,
        )
        new_industry = clone_model(industry, session)
        session.add(
            new_industry
        )  # we commit twice, because we want to get the autogenerated id. There's probably a better way
        session.add(
            industry # seems to be transient after we committed it, which is a bit weird - so bring it out again, because we're going to modify it
        )  
        new_industry.simulation_id = new_simulation.id
        industry.successor_id=new_industry.id
        session.commit()

    # Clone all classes in this simulation

    classes = session.query(SocialClass).filter(
        SocialClass.simulation_id == template.id
    )
    for socialClass in classes:
        report(
            1,
            1,
            f"Cloning class {socialClass.name}",
            session,
        )
        new_class = clone_model(socialClass, session)
        session.add(
            new_class
        )  # we commit twice, because we want to get the autogenerated id. There's probably a better way
        session.add(
            socialClass # seems to be transient after we committed it, which is a bit weird - so bring it out again, because we're going to modify it
        )  
        new_class.simulation_id = new_simulation.id
        socialClass.successor_id=new_class.id
        session.commit()

    # Clone all stocks in this simulation

    stocks = session.query(Stock).filter(Stock.simulation_id == template.id)
    for stock in stocks:
        report(
            1,
            1,
            f"Cloning stock {stock.name} with id {stock.id}, owner id {stock.owner(session).id} , and commodity  {stock.commodity(session).name} [id {stock.commodity(session).id}]",
            session,
        )
        old_owner = stock.owner(session)
        old_commodity= stock.commodity(session)
        old_stock_owner_id=stock.owner_id
        successor_commodity_id=old_commodity.successor_id
        successor_id=old_owner.successor_id
        new_stock = clone_model(stock, session)
        session.add(
            new_stock
        )  # we commit twice, because we want to get the autogenerated id. There's probably a better way
        new_stock.simulation_id = new_simulation.id
        # This stock now has to be connected with its owner and commodity objects in the new simulation
        new_stock.owner_id=successor_id
        new_stock.commodity_id=successor_commodity_id
        new_stock.name = new_stock.owner(session).name+"."+new_stock.commodity(session).name+"."+new_stock.usage_type+"."+str(new_stock.simulation_id)
        session.commit()
        print(f"  Cloned stock {new_stock.name} with id {new_stock.id}, owner id {new_stock.owner_id} commodity id {new_stock.commodity_id}")
        print(f"   The old stock whose id is {stock.id} now has an owner id of {stock.owner_id}; at the start it was {old_stock_owner_id}")
